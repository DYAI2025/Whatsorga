# Bugs & Issues — 21.02.2026

Gesammelt während der Session am 21.02.2026. Status: FIXED = behoben und deployed, OPEN = noch zu fixen, KNOWN = bekannt aber kein Fix geplant.

---

## KRITISCH

### BUG-001: 18x Nachrichtenduplizierung [FIXED]

**Problem**: Jede WhatsApp-Nachricht wurde 18-25x in der Datenbank gespeichert. "Die Mädelsrunde" erschien 18x, "Ja" sogar 25x.

**Root Cause (Extension)**: `generateMessageId()` nutzte `element.textContent` (roher DOM-Inhalt) statt extrahierten Text. Wenn WhatsApp Web den DOM aktualisiert (Lesebestätigungen → blaue Häkchen, Reaktionen), ändert sich `textContent` minimal → neuer Hash → Dedup-Check greift nicht → Nachricht wird erneut gesendet.

**Root Cause (Server)**: Der Ingest-Endpoint (`POST /api/ingest`) hatte **keinerlei Dedup-Check**. Jede empfangene Nachricht wurde blind in die DB geschrieben.

**Auswirkungen**:
- 18x LLM-Calls pro Nachricht für Termin-Extraktion (Groq API waste)
- 18x EverMemOS Memorization (verschmutzt semantisches Gedächtnis)
- Duplikate Termine in DB + Kalender
- Reflection Agent analysierte denselben Text 18x → verzerrte Insights
- DB aufgebläht: 3778 statt ~267 Nachrichten in 7 Tagen

**Fix**:
1. Server-side: Dedup-Check auf `(chat_id, sender, text, timestamp)` vor DB-Insert (`ingestion/router.py`)
2. Extension: Neue `generateStableId(prePlainText, extractedText)` nutzt extrahierten Text statt DOM-Content (`content.js`)
3. DB-Cleanup: 4311 Duplikat-Nachrichten + 4327 Duplikat-Analysen gelöscht

**Commit**: `e5917d7`
**Validierung**: Extension muss in Chrome neu geladen werden. Server-Dedup fängt auch ohne Extension-Update ab.

---

### BUG-002: "Proviant einpacken" als Kalendertermin [FIXED]

**Problem**: "Proviant und Wasser für Enno packen" wurde als eigenständiger Termin extrahiert (auto, confidence 0.95), obwohl es eine Vorbereitung für den existierenden "Enno Wettkampf"-Termin ist.

**Root Cause**: SYSTEM_PROMPT hatte keine Regel für Vorbereitungs-Tasks. Das LLM behandelte jede Handlungsaufforderung als eigenständigen Termin.

**Fix**: DIMENSION 3 (HANDLUNGSBEDARF) im SYSTEM_PROMPT erweitert:
```
- Vorbereitungen die sich auf einen BESTEHENDEN Termin beziehen → KEIN separater Kalendereintrag!
  • "Ich packe Proviant ein" (bezieht sich auf existierenden Wettkampf) → leeres Array []
  • "Muss noch Kuchen backen" (bezieht sich auf existierenden Geburtstag) → leeres Array []
```

**Commit**: `c30d23b` (Code), `e5917d7` (Docker rebuild + deploy)
**Validierung**: SYSTEM_PROMPT auf VPS verifiziert. Nächster Prep-Task-Fall muss beobachtet werden.

---

### BUG-003: "bis 18 Uhr" als Startzeit [FIXED]

**Problem**: "Enno Wettkampf bis 18 Uhr" wurde mit `datetime: 2026-02-20T18:00` extrahiert. 18:00 ist die ENDZEIT, nicht die Startzeit.

**Root Cause**: SYSTEM_PROMPT hatte keine explizite Unterscheidung zwischen Start- und Endzeiten. Das LLM übernahm die erste genannte Uhrzeit als Startzeit.

**Fix**: Neuer Abschnitt "UHRZEITEN — DENKE NACH!" im SYSTEM_PROMPT:
```
- "bis 18 Uhr" = ENDZEIT, NICHT Startzeit!
  • Wettkampf "bis 18 Uhr" → der Wettkampf ENDET um 18 Uhr, er BEGINNT früher!
  • Bei NEUEM Termin mit nur Endzeit: "all_day": true
  • Bei UPDATE: bestehende Startzeit behalten, Endzeit in Titel
```

**Commit**: `c30d23b`

---

## HOCH

### BUG-004: Cross-Message Termin Resolution funktionierte nicht [FIXED]

**Problem**: Wenn jemand fragt "Wann geht das denn morgen los?" und die Antwort "13:45-18 Uhr Turnierschwimmen" kommt, wurde kein Termin extrahiert. Die Uhrzeit war in Nachricht B, das Datum ("morgen") in Nachricht A.

**Root Cause** (3 Faktoren):
1. `_might_contain_date()` prüfte nur die aktuelle Nachricht, nicht den Konversations-Kontext
2. Konversations-Kontext zeigte nur `[HH:MM]` Zeitstempel — keine Daten
3. SYSTEM_PROMPT hatte keine Anweisung für Q&A-Pattern

**Fix**:
1. `_might_contain_date(text, context="")` — akzeptiert jetzt Konversations-Kontext
2. `strftime("%d.%m. %H:%M")` statt `strftime("%H:%M")` in Context-Formatierung
3. Neuer Block "NACHRICHTEN-ÜBERGREIFENDE TERMIN-ERKENNUNG" im SYSTEM_PROMPT

**Commit**: `c30d23b`
**Validierung**: Noch nicht mit echten Cross-Message-Fällen getestet. Muss beobachtet werden.

---

### BUG-005: Duplikat-Termine statt Updates [OPEN]

**Problem**: "Enno Wettkampf" existierte 2x in der DB (einmal mit falscher 18:00 Startzeit, einmal mit 17:30). "Treffen bei Marike" existierte ebenfalls 2x (erstellt innerhalb von 1 Minute).

**Root Cause**:
1. Duplikat-Messages (BUG-001) triggerten jeweils eigene Termin-Extraktionen
2. Das LLM nutzt `action: "update"` mit `updates_termin_id` zu selten — erstellt lieber neue Einträge
3. Die Title-Word-Overlap Duplikat-Erkennung in `_is_duplicate()` ist zu simpel

**Workaround**: Server-side Dedup (BUG-001 Fix) verhindert die häufigste Ursache. Aber LLM-seitige Duplikate (verschiedene Nachrichten über denselben Termin) bleiben möglich.

**Vorgeschlagener Fix**:
- Strengere Duplikat-Erkennung: Embedding-Similarity statt Word-Overlap
- LLM-Prompt verstärken: "PRÜFE IMMER ERST die EXISTIERENDE-TERMINE-LISTE vor CREATE"
- Post-Filter: Zeitfenster-Check (gleicher Tag, ähnlicher Titel → Block)

---

### BUG-006: "Am kontextuellen Verstehen arbeiten (System)" Meta-Termin [FIXED]

**Problem**: Das System extrahierte einen Termin über sich selbst: "Am kontextuellen Verstehen arbeiten (System)" (auto, confidence 0.85). Entstand wahrscheinlich aus einer Nachricht über System-Arbeit, die im selben Chat war.

**Root Cause**: Kein Filter für Meta-Referenzen oder System-bezogene Texte.

**Fix**: Manuell aus DB gelöscht. Kein systematischer Fix implementiert.

**Vorgeschlagener Fix**:
- Blocklist in Gate-Funktion: Nachrichten die "System", "Claude", "API", "WhatsOrga" enthalten → Skip
- Oder: Confidence-Threshold für "task"-Kategorie erhöhen

---

### BUG-007: Vergangene Termine werden extrahiert [OPEN]

**Problem**: Termine wie "Enno Ankunft am Eingang" (11.02.), "Ben Ankunft" (13.02.) stehen in der DB obwohl sie in der Vergangenheit liegen. Wahrscheinlich aus älteren Nachrichten extrahiert die per Extension/Reimport kamen.

**Root Cause**: Kein Vergangenheits-Filter. Die DIMENSION 6 (Intention) sagt zwar "Vergangenheit = kein Termin", aber das LLM ignoriert es manchmal.

**Vorgeschlagener Fix**:
- Post-Filter in `extract_termine_with_context()`: Wenn `datetime < now - 24h` → Skip
- Ausnahme: Wiederkehrende Termine (Geburtstage, jährliche Events)

---

## MITTEL

### BUG-008: EverMemOS Recall liefert "0 memory items" [OPEN]

**Problem**: Logs zeigen konsistent `Termin extraction with 0 memory items` für fast jede Nachricht, obwohl 2458 Memcells, 924 Episoden und 100 semantische Memories existieren.

**Mögliche Ursachen**:
1. Recall-Query zu spezifisch oder zu unspezifisch
2. Embedding-Space-Mismatch (Qwen3 vs. was bei Memorize genutzt wurde)
3. Chat-ID-Filter zu restriktiv
4. Milvus-Index nicht aktuell

**Impact**: Ohne Memory-Kontext fehlt dem Termin-Extractor wichtiges Hintergrundwissen (z.B. "Enno trainiert dienstags und donnerstags").

**Diagnose nötig**:
```bash
# Manueller Recall-Test
curl -X POST http://localhost:8001/api/v3/agentic/retrieve_lightweight \
  -H "Content-Type: application/json" \
  -d '{"query": "Enno Training Schwimmen", "chat_id": "Marike Stucke", "top_k": 5}'
```

---

### BUG-009: Marker Registry fehlt auf VPS [OPEN]

**Problem**: `marker_registry_radar.json` fehlt → Legacy Marker Engine als Fallback aktiv. Warning: "Marker registry not found, using legacy fallback".

**Root Cause**: Die Registry wird aus externen Marker-Daten kompiliert (`scripts/compile_registry.py`), die nicht im Git-Repo liegen. Auf dem VPS wurde die Kompilierung nie ausgeführt.

**Fix**:
```bash
cd /opt/Whatsorga/radar-api
python -m scripts.compile_registry \
  --markers-dir ../../Marker/WTME_ALL_Marker-LD3.4.1-5.1 \
  --category-mapping data/category_mapping.yaml \
  --output data/marker_registry_radar.json
```
Aber: Die Marker-Daten (`WTME_ALL_Marker-*`) müssen erst auf den VPS kopiert werden.

---

### BUG-010: Gemini 2.5 Flash JSON-Parse-Fehler [KNOWN]

**Problem**: Gemini 2.5 Flash (Fallback-LLM) produziert häufig Reasoning-Text ohne valides JSON. `_parse_extraction_response()` hat Multi-Strategy-Parsing (JSON-Block-Extraktion, Bracket-Matching), aber Gemini bricht trotzdem regelmäßig.

**Root Cause**: Gemini folgt dem JSON-Output-Format weniger zuverlässig als Llama 3.3.

**Impact**: Wenn Groq ausfällt (Rate-Limit, Timeout), ist der Fallback unzuverlässig. Effektiv Single-LLM-System.

**Vorgeschlagener Fix**:
- Gemini-spezifischen Prompt-Wrapper (z.B. "ONLY output JSON, no reasoning text")
- Oder: Alternative Fallback-LLMs evaluieren (Mistral, Qwen)
- Oder: Groq-Rate-Limit-Management (Backoff + Queue statt sofortiger Fallback)

---

### BUG-011: Docker Image nicht automatisch rebuilt nach Deploy [KNOWN]

**Problem**: `git pull` auf dem VPS aktualisiert den Code, aber das Docker Image wird nicht automatisch neu gebaut. Der laufende Container nutzt weiterhin das alte Image bis `docker compose build radar-api` manuell ausgeführt wird.

**Root Cause**: Kein CI/CD. Deployment ist manuell.

**Impact**: Code-Fixes (wie BUG-002) waren im Git aber nicht im laufenden Container. Falsche Annahme dass der Fix "deployed" ist.

**Vorgeschlagener Fix**:
- Deploy-Script: `git pull && docker compose build radar-api && docker compose up -d radar-api`
- Oder: GitHub Actions Webhook → Auto-Deploy
- Oder: Watchtower für automatische Image-Updates

---

### BUG-012: YAML-Merge-Konflikte durch Reflection Agent [OPEN]

**Problem**: Der Reflection Agent schreibt YAML-Updates direkt auf dem VPS. Wenn dann `git pull` gemacht wird, entstehen Merge-Konflikte (am 21.02. bei `romy.yaml`).

**Root Cause**: Kein Sync-Mechanismus. VPS hat lokale Änderungen, Git hat andere Änderungen.

**Vorgeschlagene Lösungen** (priorisiert):
1. **Auto-Commit auf VPS**: Nach jeder Reflection → `git add data/persons/ && git commit -m "reflect: ..." && git push`
2. **Separate Branch**: Reflection schreibt in `reflect/main`, manueller Merge
3. **VPS als Truth**: Person-YAMLs nur auf VPS editieren, nie lokal
4. **.gitignore**: `data/persons/*.yaml` aus Git nehmen, nur auf VPS

---

## NIEDRIG

### BUG-013: Reflection Agent falsche Datumsinterpretation [FIXED]

**Problem**: Reflection Agent inferierte "Kindergeburtstag am 20.02." statt korrektem 21.02.

**Root Cause**: LLM-Halluzination — der Agent interpretierte den Kontext falsch.

**Fix**: Manuell in `romy.yaml` korrigiert (lokal + VPS).

**Lektion**: Reflection-Learnings sollten idealerweise vor dem Schreiben validiert werden. Aber: zu viel Kontrolle tötet die Autonomie.

---

### BUG-014: "Marike fährt los" als eigenständiger Termin [OPEN]

**Problem**: "Marike fährt los" (confidence 0.99, auto) ist kein sinnvoller Kalendereintrag. Es ist eine Statusmeldung, kein Termin.

**Root Cause**: DIMENSION 6 (Intention) unterscheidet nicht gut genug zwischen "informiert über Bewegung" und "echter Termin". Das LLM interpretiert konkrete Uhrzeiten + Handlungsverben zu aggressiv als Termine.

**Vorgeschlagener Fix**:
- Neue Regel: "Reine Statusmeldungen ('bin unterwegs', 'fährt los', 'bin da') = KEIN Termin, auch wenn Uhrzeit erkennbar"
- Confidence-Threshold für solche Fälle senken

---

### BUG-015: "Bela abholen" — Unbekannte Person [OPEN]

**Problem**: Termin "Bela abholen" extrahiert (confidence 0.95). Bela ist kein Familienmitglied mit YAML-Profil.

**Fragen**:
- Ist Bela relevant? (Freund, Haustier, Nachbarskind?)
- Sollte ein Bela-Profil erstellt werden?
- Oder: Filter auf bekannte Personen?

**Lektion**: Das System braucht eine Strategie für unbekannte Personen: ignorieren, nachfragen, oder mit niedrigerem Confidence erstellen.

---

## Systematische Muster

### Pattern A: LLM über-extrahiert
BUG-002, BUG-006, BUG-014 — das LLM erstellt zu viele Termine. Lieber einen übersehen als einen falschen erstellen.

**Vorschlag**: Confidence-Floor anheben. Aktuell `auto ≥ 0.85`. Vielleicht `auto ≥ 0.90`?

### Pattern B: Duplikate auf allen Ebenen
BUG-001 (Messages), BUG-005 (Termine), BUG-012 (YAML) — Duplikate sind das häufigste Problem.

**Vorschlag**: Idempotenz als Design-Prinzip. Jede Operation sollte sicher mehrfach ausführbar sein.

### Pattern C: Vergangenheit vs. Zukunft
BUG-007, BUG-014 — das System unterscheidet schlecht zwischen "war" und "wird sein".

**Vorschlag**: Harter Post-Filter: `datetime < now - 24h → drop` (mit Whitelist für recurring events).
